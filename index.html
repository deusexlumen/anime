<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DEMOKRATIE 2.0 | Der Abstieg in die Souver√§nit√§t</title>
    <style>
        :root {
            --void: #050505;
            --gold: #d4af37;
            --platinum: #e5e4e2;
            --gold-dim: rgba(212, 175, 55, 0.3);
            --font-main: 'Helvetica Neue', Arial, sans-serif;
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            background-color: var(--void);
            color: var(--platinum);
            font-family: var(--font-main);
            overflow-x: hidden;
            height: 15000px; /* Physische Tiefe des Tunnels */
        }

        /* --- LAYER 0: CANVAS (PARTIKEL) --- */
        #sovereign-field {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: 0;
            pointer-events: none;
        }

        /* --- LAYER 1: TUNNEL (VIEWPORT) --- */
        #tunnel-viewport {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            perspective: 1000px; /* Tiefe der Kamera */
            z-index: 1;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            /* Performance Hack */
            backface-visibility: hidden; 
        }

        #tunnel-world {
            position: absolute;
            width: 100%;
            height: 100%;
            transform-style: preserve-3d;
            will-change: transform;
        }

        .node {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 80vw;
            max-width: 800px;
            text-align: center;
            /* Wichtig: Initial versteckt, damit kein FOUC (Flash of Unstyled Content) passiert */
            opacity: 0; 
            transform: translate(-50%, -50%);
        }

        /* Fail-Safe f√ºr Nutzer ohne JS: Inhalte werden untereinander angezeigt */
        @noscript {
            .node {
                position: relative;
                opacity: 1;
                transform: none;
                margin-bottom: 100px;
                top: auto;
                left: auto;
            }
            #tunnel-viewport { position: relative; height: auto; perspective: none; }
            #tunnel-world { position: relative; height: auto; }
            body { height: auto; overflow-y: scroll; }
        }

        /* Typografie & UI */
        h1 {
            font-size: clamp(3rem, 5vw, 6rem);
            text-transform: uppercase;
            letter-spacing: 0.2em;
            color: var(--gold);
            margin-bottom: 1rem;
            text-shadow: 0 0 30px var(--gold-dim);
        }

        h2 {
            font-size: 2rem;
            color: var(--platinum);
            font-weight: 300;
            border-bottom: 1px solid var(--gold);
            display: inline-block;
            padding-bottom: 0.5rem;
            margin-bottom: 2rem;
        }

        p {
            font-size: 1.2rem;
            line-height: 1.6;
            max-width: 600px;
            margin: 0 auto;
        }

        .media-container {
            margin-top: 2rem;
            border: 1px solid var(--gold);
            padding: 2rem;
            background: rgba(5, 5, 5, 0.9);
            box-shadow: 0 0 50px rgba(0,0,0,0.8);
        }

        .icon {
            font-size: 4rem;
            display: block;
            margin-bottom: 1rem;
            filter: drop-shadow(0 0 10px var(--gold));
        }

        /* --- OUTRO / NAVIGATION --- */
        .outro-links {
            display: flex;
            gap: 2rem;
            justify-content: center;
            margin-top: 3rem;
            flex-wrap: wrap;
        }

        .btn {
            padding: 1rem 2rem;
            border: 1px solid var(--gold);
            color: var(--gold);
            text-decoration: none;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            transition: all 0.4s cubic-bezier(0.25, 1, 0.5, 1);
            position: relative;
            overflow: hidden;
        }

        .btn:hover {
            background: var(--gold);
            color: var(--void);
            box-shadow: 0 0 25px var(--gold);
        }

        /* Scroll-Bar verstecken f√ºr Immersion */
        ::-webkit-scrollbar { width: 0; }
        html { scrollbar-width: none; }
        
        #loading-overlay {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: var(--void);
            z-index: 9999;
            display: flex;
            justify-content: center;
            align-items: center;
            color: var(--gold);
            font-family: monospace;
            transition: opacity 1s ease;
        }
    </style>
</head>
<body>

    <div id="loading-overlay">Œ¶ | RE-CALIBRATING SOVEREIGNTY...</div>

    <canvas id="sovereign-field"></canvas>

    <div id="tunnel-viewport">
        <div id="tunnel-world">
            
            <section class="node" id="prolog" data-z="0">
                <h1>Stasis</h1>
                <p>Der politische Stau. Parteien als Gatekeeper.<br>Willkommen im Ende der Geschichte.</p>
                <div style="margin-top: 3rem; font-size: 0.8rem; color: var(--gold); animation: pulse 2s infinite;">SCROLL TO DESCEND</div>
            </section>

            <section class="node" id="act-1" data-z="3000">
                <span class="icon">üèõÔ∏è</span>
                <h2>Der Ursprung</h2>
                <div class="media-container">
                    <p><strong>[AUDIO-SLOT: Aristoteles & Die Isonomie]</strong></p>
                    <br>
                    <p><i>"Wahlen sind oligarchisch, das Los ist demokratisch."</i></p>
                </div>
            </section>

            <section class="node" id="act-2" data-z="6000">
                <span class="icon">‚öñÔ∏è</span>
                <h2>Die Logik des Zufalls</h2>
                <div class="media-container">
                    <p><strong>[VIDEO-SLOT: Wahl vs. Los]</strong></p>
                    <br>
                    <p>Kompetenz entsteht nicht durch Karrierismus, sondern durch kognitive Diversit√§t.</p>
                </div>
            </section>

            <section class="node" id="act-3" data-z="9000">
                <span class="icon">üå™Ô∏è</span>
                <h2>Die Moderne Krise</h2>
                <div class="media-container">
                    <p><strong>[AUDIO-SLOT: Gegen Wahlen]</strong></p>
                    <br>
                    <p>Warum wir unsere Demokratie retten m√ºssen, indem wir sie neu erfinden.</p>
                </div>
            </section>

            <section class="node" id="act-4" data-z="12000">
                <span class="icon">‚ú®</span>
                <h2>Demokratie 2.0</h2>
                <div class="media-container">
                    <p><strong>[VIDEO-SLOT: Die Kinetische Isonomie]</strong></p>
                    <br>
                    <p>Keine Politiker mehr. B√ºrger. Verantwortung. Freiheit.</p>
                </div>
            </section>

            <section class="node" id="outro" data-z="15000">
                <h1>Souver√§nit√§t</h1>
                <p>Du bist am Grund angekommen. Baue neu.</p>
                <div class="outro-links">
                    <a href="#" class="btn">Manifest (PDF)</a>
                    <a href="https://www.youtube.com/@ArdalanIbrahim" target="_blank" class="btn">NUTT LOS (YT)</a>
                </div>
            </section>

        </div>
    </div>

    <script type="module">
        // BUGFIX IMPORT: Wir nutzen das BUNDLE, da raw modules im Browser oft CORS/MIME-Probleme machen.
        // Stellen Sie sicher, dass der Pfad exakt stimmt:
        import { 
            animate, 
            utils 
        } from './dist/bundles/anime.esm.js';

        // --- KONFIGURATION ---
        const CONFIG = {
            tunnelDepth: 15000, 
            particleCount: 250,
            gold: '#d4af37',
            fadeDistance: 1200 // Distanz, ab der Elemente sichtbar werden
        };

        // --- DOM REFS ---
        const world = document.getElementById('tunnel-world');
        const nodes = document.querySelectorAll('.node');
        const canvas = document.getElementById('sovereign-field');
        const ctx = canvas.getContext('2d');
        const loader = document.getElementById('loading-overlay');

        // --- PRE-CALCULATION ---
        // Wir platzieren die Nodes initial im 3D Raum
        nodes.forEach(node => {
            const z = parseInt(node.getAttribute('data-z'));
            // Wir setzen sie hart, Anime.js √ºbernimmt sp√§ter die Feinheiten
            node.style.transform = `translate(-50%, -50%) translateZ(${z}px)`;
        });

        // --- ENGINE START ---
        // Kurzer Timeout f√ºr Setup, dann Loader weg
        window.addEventListener('load', () => {
            setTimeout(() => {
                loader.style.opacity = '0';
                setTimeout(() => loader.remove(), 1000);
            }, 800);
        });

        // --- KINETIC CORE (SCROLLYTELLING) ---
        let currentScroll = 0;
        let targetScroll = 0;
        
        // Loop f√ºr smooth scrolling (Lerp)
        function updateTunnel() {
            targetScroll = window.scrollY;
            // Lerp Factor: 0.08 f√ºr etwas mehr "Gewicht" (Schweregef√ºhl der Souver√§nit√§t)
            currentScroll += (targetScroll - currentScroll) * 0.08;

            // 1. Welt bewegen (Kamerafahrt)
            // Wir bewegen die Welt auf uns zu (negative Z)
            const zPos = -currentScroll;
            // Leichte Rotation f√ºr Desorientierungseffekt
            const rotation = currentScroll * 0.001;
            
            world.style.transform = `translateZ(${zPos}px) rotateZ(${rotation}deg)`;

            // 2. Nodes Sichtbarkeit berechnen
            nodes.forEach(node => {
                const nodeZ = parseInt(node.getAttribute('data-z'));
                // Distanz zur Kamera
                const dist = Math.abs(nodeZ - currentScroll);

                if (dist < CONFIG.fadeDistance) {
                    // Normalisierter Wert (0 bis 1)
                    const progress = 1 - (dist / CONFIG.fadeDistance);
                    // Easing f√ºr die Opacity (Cubic In)
                    const opacity = Math.pow(progress, 2);
                    
                    node.style.opacity = opacity;
                    // Blur Effekt f√ºr Tiefe
                    const blur = (1 - opacity) * 10;
                    node.style.filter = `blur(${blur}px)`;
                    
                    // Leichter Scale-Effekt beim N√§herkommen
                    const scale = 0.8 + (opacity * 0.2);
                    node.style.transform = `translate(-50%, -50%) translateZ(${nodeZ}px) scale(${scale})`;
                } else {
                    node.style.opacity = 0;
                    node.style.pointerEvents = 'none'; // Keine Klicks auf unsichtbare Elemente
                }
                
                // Aktiviere Pointer Events nur wenn voll sichtbar
                if(node.style.opacity > 0.8) {
                    node.style.pointerEvents = 'all';
                }
            });

            requestAnimationFrame(updateTunnel);
        }
        updateTunnel(); // Start Loop


        // --- PARTICLE SYSTEM (VISUALS) ---
        let width, height;
        const particles = [];

        function resize() {
            width = canvas.width = window.innerWidth;
            height = canvas.height = window.innerHeight;
        }
        window.addEventListener('resize', resize);
        resize();

        class Particle {
            constructor() {
                this.init(true);
            }
            
            init(randomZ = false) {
                this.x = Math.random() * width;
                this.y = Math.random() * height;
                // Z Tiefe f√ºr Parallax
                this.depth = Math.random() * 0.5 + 0.1; 
                this.size = Math.random() * 2;
                this.alpha = Math.random() * 0.5 + 0.2;
                // Geschwindigkeit
                this.vx = (Math.random() - 0.5) * 0.5;
                this.vy = (Math.random() - 0.5) * 0.5;
            }

            update(scrollSpeed) {
                // Scroll beeinflusst Partikel (Turbulenz)
                const speedFactor = 1 + (scrollSpeed * 0.05);
                
                this.x += this.vx * speedFactor;
                this.y += this.vy * speedFactor;

                // Wrap edges
                if (this.x > width) this.x = 0;
                if (this.x < 0) this.x = width;
                if (this.y > height) this.y = 0;
                if (this.y < 0) this.y = height;
            }

            draw() {
                ctx.fillStyle = CONFIG.gold;
                ctx.globalAlpha = this.alpha;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size * this.depth, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        // Init
        for(let i=0; i < CONFIG.particleCount; i++) {
            particles.push(new Particle());
        }

        // Render Loop Partikel
        let lastScroll = 0;
        function renderParticles() {
            ctx.clearRect(0, 0, width, height);
            
            // Berechne Scroll-Geschwindigkeit f√ºr "Warp"-Effekt
            const scrollSpeed = Math.abs(window.scrollY - lastScroll);
            lastScroll = window.scrollY;

            particles.forEach(p => {
                p.update(scrollSpeed);
                p.draw();
            });
            requestAnimationFrame(renderParticles);
        }
        renderParticles();
        
        // --- HAPTIK (MOUSE PARALLAX) ---
        // Nutzt Anime.js f√ºr weiche Interpolation der Mauswerte
        const mouseData = { x: 0, y: 0 };
        
        document.addEventListener('mousemove', (e) => {
            const targetX = (e.clientX / width - 0.5) * 30;
            const targetY = (e.clientY / height - 0.5) * 30;
            
            // Anime.js set nutzen wir nicht im Loop, sondern wir animieren die Werte
            // Hier nutzen wir einfache JS Interpolation im Tunnel-Loop oder separat.
            // Um "Architect Zero" treu zu bleiben, integrieren wir das in den Viewport.
            
            const viewport = document.getElementById('tunnel-viewport');
            viewport.style.transform = `translateX(${-targetX}px) translateY(${-targetY}px)`;
        });

    </script>
    
    <style>
        @keyframes pulse {
            0% { opacity: 0.5; transform: scale(1); }
            50% { opacity: 1; transform: scale(1.1); }
            100% { opacity: 0.5; transform: scale(1); }
        }
    </style>
</body>
</html>
